Para evitar que seu cÃ³digo fique preso a uma biblioteca externa (que pode mudar no futuro),
vocÃª pode usar o padrÃ£o Adapter.
Ele cria uma â€œponteâ€ entre seu cÃ³digo e a biblioteca, usando uma interface prÃ³pria.
Assim, se trocar a biblioteca, sÃ³ precisa mudar o adapter â€” o resto do sistema continua igual.

Outro ponto relevante eh deixar a implementacao toda baseada nas interfaces, pois o 'miolo' pode mudar,
mas a assinatura pode se manter a mesma reduzindo a necessidade de grande alteraÃ§Ã£o.

Vantagens:
- CÃ³digo mais flexÃ­vel e fÃ¡cil de manter
- Facilita testes
- Troca de biblioteca sem dor de cabeÃ§a

Desvantagens:
- Mais cÃ³digo para escrever
- Precisa atualizar o adapter se quiser usar novas funÃ§Ãµes


## ğŸ§© Exemplo

Seu sistema REST chama um serviÃ§o de cadastro de usuÃ¡rios.
Esse serviÃ§o Ã© SOAP, mas vocÃª quer manter seu cÃ³digo REST desacoplado, caso troque o serviÃ§o no futuro.

---

## âœ… Passo 1: Interface REST interna

```java
public interface CadastroService {
    void cadastrarUsuario(String nome, String email);
}
```

---

## ğŸ”„ Passo 2: Adapter para o serviÃ§o SOAP

```java
public class SoapCadastroAdapter implements CadastroService {
    private SoapCadastroClient soapClient = new SoapCadastroClient(); // cliente gerado via WSDL

    @Override
    public void cadastrarUsuario(String nome, String email) {
        soapClient.enviarDados(nome, email); // mÃ©todo do serviÃ§o SOAP
    }
}
```

---

## ğŸŒ Passo 3: Uso no controller REST

```java
@RestController
public class UsuarioController {
    private final CadastroService cadastroService;

    public UsuarioController(CadastroService cadastroService) {
        this.cadastroService = cadastroService;
    }

    @PostMapping("/usuarios")
    public ResponseEntity<String> cadastrar(@RequestBody UsuarioDTO dto) {
        cadastroService.cadastrarUsuario(dto.getNome(), dto.getEmail());
        return ResponseEntity.ok("UsuÃ¡rio cadastrado com sucesso");
    }
}
```

---

## ğŸ§ª InjeÃ§Ã£o do Adapter

```java
@Configuration
public class AppConfig {
    @Bean
    public CadastroService cadastroService() {
        return new SoapCadastroAdapter(); // pode trocar por outro adapter no futuro
    }
}
```

---

## ğŸ”„ Trocar o serviÃ§o SOAP por REST? SÃ³ mudar o adapter:

```java
public class RestCadastroAdapter implements CadastroService {
    private RestTemplate restTemplate = new RestTemplate();

    @Override
    public void cadastrarUsuario(String nome, String email) {
        UsuarioDTO dto = new UsuarioDTO(nome, email);
        restTemplate.postForEntity("https://api.exemplo.com/usuarios", dto, Void.class);
    }
}
```

---

Com isso, seu controller REST continua igual, e vocÃª pode trocar o serviÃ§o externo
sem mexer no restante do sistema.